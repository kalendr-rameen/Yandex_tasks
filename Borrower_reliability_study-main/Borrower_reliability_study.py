#!/usr/bin/env python
# coding: utf-8

# # Задача: исследование надёжности заёмщиков
# 
# Заказчик — кредитный отдел банка. Нужно разобраться, влияет ли семейное положение и количество детей клиента на факт погашения кредита в срок. Входные данные от банка — статистика о платёжеспособности клиентов.
# 
# Результаты исследования будут учтены при построении модели **кредитного скоринга** — специальной системы, которая оценивает способность потенциального заёмщика вернуть кредит банку.
# 

# **Описание данных**<br>
# children — количество детей в семье<br>
# days_employed — общий трудовой стаж в днях<br>
# dob_years — возраст клиента в годах<br>
# education — уровень образования клиента<br>
# education_id — идентификатор уровня образования<br>
# family_status — семейное положение<br>
# family_status_id — идентификатор семейного положения<br>
# gender — пол клиента<br>
# income_type — тип занятости<br>
# debt — имел ли задолженность по возврату кредитов<br>
# total_income — ежемесячный доход<br>
# purpose — цель получения кредита<br>

# ## 1. Создание датафрейма

# In[1]:


import pandas as pd
df = pd.read_csv("./data.csv")
df.info()


# ## 2. Предобработка данных

# ### 2.1 Обработка пропусков

# In[2]:


def age_grouping(row):
    ages = row['dob_years']
    if ages <= 21:
        return "Юный возраст"
    elif ages > 21 and ages <= 35:
        return "Зрелый возраст I"
    elif ages > 35 and ages <= 57:
        return "Зрелый возраст II"
    else:
        return "Пожилой возраст"


# In[3]:


df['age_group'] = df.apply(age_grouping, axis=1)


# In[4]:


df['days_employed'] = df['days_employed'].fillna(df.groupby(['gender','age_group'])['days_employed'].transform('median'))


# In[5]:


df['total_income'] = df['total_income'].fillna(df.groupby(['gender','age_group'])['total_income'].transform('median'))


# **Вывод**<br>
# Cкорее всего просто говорить что раз нет рабочего стажа значит и нет никаких заработков скорее всего не верно, тк все люди так или иначе имели работу за исключением пенсионеров, но им полагается пенсия так что доход должен быть видимо у всех групп где были пропуски, поэтому я решил что нужно заменить все пропущенные значения на медианы значений из соответсвущих групп, не стал такого делать только лишь для предпренимателя т.к их всего 2-е(двое) и если я возьму значения из столбцов второго предпринимателя то это будет скорее всего не верно т.к медиана скорее всего не будет отражать реальности. Также просто потеря данных не очень хорошо т.к мы теоретически теряем данные для будущей статистики, поэтому замена данных самая логичная стратегия

# ### 2.2 Замена типа данных

# In[6]:


df['days_employed'] = df['days_employed'].astype('int64')
df['total_income'] = df['total_income'].astype('int64')


# In[7]:


df.info()


# **Вывод**

# Т.к мне не нужно переводить из str в float, а из float к int то нужно использовать метод astype()

# ### 2.3 Обработка дубликатов

# In[8]:


df["education"].value_counts()


# In[9]:


df["education"] = df["education"].str.lower()


# In[10]:


df['family_status'] = df['family_status'].str.lower()


# In[11]:


df["income_type"] = df['income_type'].str.lower()


# In[12]:


df["purpose"] = df["purpose"].str.lower()


# In[13]:


df["days_employed"] = df["days_employed"].abs()


# In[14]:


df.head(10)


# In[15]:


df["education"].value_counts()


# In[16]:


df['family_status'].value_counts()


# In[17]:


df["duplica"] = df.duplicated()


# In[18]:


df[df['duplica'] == True].head(15)


# In[19]:


df = df.drop_duplicates().reset_index(drop=True)


# In[20]:


df.duplicated().sum()


# **Вывод** 
# 

# Причина возникновения дупликатов не совсем ясна, но я предполгаю что просто одинаковые люди приходили брали кредит, на одни и те же цели. А сами дупликаты были найдены с помощью того что были все строчные столбцы приведены к одному регистру и заменены отрицательные значения столбцов на положительные как в столбце days_employed, где явно была допущена ошибка при заполнение.

# ### 2.4 Лемматизация

# In[21]:


from pymystem3 import Mystem
m = Mystem()


# In[22]:


df['purpose'].value_counts()


# In[23]:


lemmas = []


# In[24]:


for i in range(1,df.shape[0]):
    all = m.lemmatize(df.loc[i,'purpose'])
    for b in all:
        lemmas.append(b)


# In[25]:


from collections import Counter
print(Counter(lemmas))


# **Вывод**

# Лемматизация была проведена по всем словам из колонки 'purpose' путем слияния всех лемм в один спискок и дальнейшим подсчётом слов, таким образом можно увидеть какие основные позиции можно выделить в дальнейшем для категоризации данных такие как :недвижимость/жилье, образование, автомобиль, Свадьба

# ### 2.5 Категоризация данных

# In[26]:


import pandas as pd
from pymystem3 import Mystem
m = Mystem()
def _group_(row):
    
    purp = row['purpose']
    if ('недвижимость' in m.lemmatize(purp)) or ("жилье" in m.lemmatize(purp)):
        return "Операции Жильё/Недвижимость"
    elif "автомобиль" in m.lemmatize(purp):
        return "Операции с автомобилями"
    elif "образование" in m.lemmatize(purp):
        return "Образованием"
    elif "свадьба" in m.lemmatize(purp):
        return "Свадьба"
    else:
        return "other's"


# In[27]:


df['group_purpose'] = df.apply(_group_,axis=1)


# In[28]:


df["group_purpose"].value_counts()


# **Вывод**

# Можно резделить все выбранные цели на 4 категории с которыми в дальнейшем можно производить проверку гипотез

# ## Шаг 3. Ответьте на вопросы

# - Есть ли зависимость между наличием детей и возвратом кредита в срок?

# In[29]:


df.groupby("children")["debt"].sum()/df.groupby('children')['debt'].count() * 100


# **Вывод**<br>
# 
# Была проведен перевод значений в проценты путем деления на количество людей в каждой группе и умножения на 100 => В среднем те кто имеют детей склонны чаще не возвращать деньги в срок

# - Есть ли зависимость между семейным положением и возвратом кредита в срок?

# In[30]:


df['family_status'].value_counts()


# In[31]:


sum = df.groupby("family_status")['debt'].sum()


# In[32]:


sum


# In[33]:


value_counts = df.groupby('family_status').count()['debt']


# In[34]:


value_counts


# In[35]:


sum/value_counts


# **Вывод**

# Можно заметить что когда человек не женат у него больше вероятность не заплатить во время, вообще видно мне кажется что в зависимости от того женат был человек или нет очень повышается вероятность т.е самая низкая у вдовцов т.к они были когда то женаты, потом в разводе т.к человек был когда то женат, затем идут женатые, затем идут не женатые или находящиеся в гражданском браке => Женатому человеку можно давать в кредит он не 'подведет', не женатому с опасением)

# - Есть ли зависимость между уровнем дохода и возвратом кредита в срок?

# In[36]:


sorted_df = df.sort_values(by="total_income")["total_income"].reset_index(drop=True)


# In[37]:


len_total_income = len(df['total_income'])
first_value = sorted_df[int(len_total_income * 0.1) - 1]
second_value = sorted_df[int(len_total_income * 0.25) - 1]
third_value = sorted_df[int(len_total_income * 0.75) - 1]
print(first_value, " " , second_value, " ", third_value)


# In[38]:


def sort_income(row):
    income = row['total_income'] 
    if income < 78785:
        return 'низкий'
    elif income >= 78785 and income < 107775:
        return "ниже_среднего"
    elif income >= 107775 and income < 195549:
        return "средний"
    else:
        return "высокий"


# In[39]:


df['sort_income'] = df.apply(sort_income, axis=1)


# In[40]:


df.head(5)


# In[41]:


df.groupby("sort_income")["debt"].sum()/df.groupby('sort_income')['debt'].count() * 100


# **Вывод**<br>
# Сначала я поделил заработок с на 4 категории: низкий, ниже среднего, средний, высокий. В интервал **низкие** зарплаты вхоидил люди с заработком из 10% диапазона отсортированных величин заработка.
# В категорию **ниже среднего** от 10 до 25%, **средний**  от 25 до 75 %, **высокий** от 75% и выше. Таким образом с помощью функции для строки получилось отфилотровать все значения  .
# 
# Самыми **безответственными** оказались люди чей заработок входит в 'средний' диапазон, богатые же люди с 'высоким' заработком оказались самыми **ответственными** всери 4 групп

# - Как разные цели кредита влияют на его возврат в срок?

# In[42]:


sum = df.groupby("group_purpose")['debt'].sum()


# In[43]:


sum


# In[44]:


group_value = df.groupby("group_purpose").count()['children']


# In[45]:


group_value


# In[46]:


sum/group_value


# **Вывод**

# В среднем те кто берет на образование и автомобили чаще не возвращают деньги в срок нежели остальные две группы

# ## Шаг 4. Общий вывод

# Как и все реальные данные, и предоствленные здесь не исключение, все имеют дупликаты пропуски, и все они были убраны с помощью специальных методов таких как fillna, str.lower, drop_duplicates. 
# Также были найдены отрацательные значения в столбце days_employed, что говорит нам что эти данные скорее возникли в следствие ошибки человека. Также я заметил что все цели кредита можно разбить на 4 категории а именно: 
# 
# -Образование
# 
# -Операции Жильё/Недвижимостью
# 
# -Операции с автомобилями
# 
# -Свадьба
# 
# После предварительной очистки данных были проверены 4 гипотезы, вследвтвие которых делается вывод о том что: 
# 
# 1.видно, что чем больше детей тем меньше вероятность что деньги будут возвращены в срок (В среднем те кто имеют детей склонны чаще не возвращать деньги в срок)
# 
# 2.женатые когда либо люди менее склонны к задежке оплаты в срок
# 
# 3.Самыми безответственными оказались люди чей заработок входит в 'средний' диапазон чей уровень невозврата составляет **8.624535%**, богатые же люди с 'высоким' заработком оказались самыми ответственными среди 4 групп и их уровень невозврата составляет **7.173388%**
# 
# 4.В среднем те кто берет на образование и автомобили чаще не возвращают деньги в срок нежели остальные две группы
